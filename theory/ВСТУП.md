# GIT

Ви можете побачити версію Git'а, яку ви встановили: 
```
git --version
```
Детальну довідкову інформацію у вигляді man-сторінки можна отримати про будь-яку підкоманду, виконавши: 
```
git help [subcommand]
```

Наприклад: 
```
git help status
```

Якщо ви не можете втриматися від перегляду повнішого набору команд, це можна зробити ось так: 
```
git help --all
```

Якщо ви створюєте новий репозиторій, найпростіший спосіб зробити це з самого початку - зробити щось на кшталт:
```
git init
git checkout -b main
```

Для вже наявних репозиторіїв ви можете перейменувати як локальну гілку, так і віддалену гілку на сервері з:
```
git checkout master
```
Змінити локальну назву
```
git branch -m master main
```

Змінити віддалену назву
```
git push -u origin main
git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main
```

Підтвердити імена!
```
git branch -a
```

Залежно від налаштувань віддаленого сервера (наприклад, GitHub) це може спрацювати, а може і не спрацювати. Простіший підхід - не видаляти гілку master, а просто скопіювати її в main і працювати звідти, як і раніше:
```
git checkout master
git branch main
git checkout main
git push -u origin main
```

а потім просто ігноруйте гілку master надалі. 

Під час ініціалізації проєкту створюється каталог .git, який міститиме всю інформацію про керування версіями. Основні каталоги, що входять до складу проєкту, залишаються недоторканими. 

Початковий вміст цього каталогу має вигляд:
```
ls -l .git
```

Далі ми створюємо файл і додаємо його до проєкту:
```
echo some junk > somejunkfile
git add somejunkfile
```

Ми можемо бачити поточний стан нашого проєкту за допомогою:
```
git status
```

Тепер давайте змінимо файл, а потім подивимося історію відмінностей:
```
echo another line >> somejunkfile
git diff
```

Для того, щоб фактично закоммітити зміни в репозиторії, ми це робимо: 
```
git add somejunkfile
git commit -m "My initial commit"
```

Ви можете переглянути свою історію за допомогою:
```
git log
```

## Підпис коммітів
Важливо знати, хто відповідає за всі зміни в репозиторії, щоб відстежувати історію і розуміти,
хто гарантує, що код, який вноситься до репозиторію, робиться з належним ліцензуванням і правом власності.
Найпростіше це зробити, додавши до комміту рядок Signed-off-by з опцією -s. Так ми могли б зробити:
```
git commit -s -m "My initial commit"
```

Кожен репозииторій також містить набір конфігураційних параметрів, таких як ім'я автора та адреса електронної пошти. Наприклад, якщо ми подивимося на файл .git/config з простого прикладу у попередньому розділі, то побачимо:
```
cat .git/config
```

 ## Основні файлові команди

```
git add
```
Додає один або кілька файлів у вигляді блобів до сховища об'єктів і додає посилання на нові блоби до змісту за допомогою sha1-хешу. Таким чином, ми індексуємо один або кілька файлів і каталогів. Він може бути використаний як для додавання нових файлів, так і для збереження змінених. Файли не будуть закоммітені, доки не буде зроблено git commit. Існує кілька варіантів (див. довідку git help add). Наприклад, ви можете використовувати -i для інтерактивного вибору файлів для стадії або -u для оновлення лише тих файлів, які вже відомі Git'у. Ви також можете вказати шаблони підстановки або імена каталогів (в яких буде додано все дерево підкаталогів). Варто повторити, що поки ви не зробите git commit, зміни лише стадіюються; репозиторій не оновлюється. 

```
git rm
```
Видаляє файл з робочого дерева та змісту (індексу), але не видаляє його з репозиторію;
це відбувається лише тоді, коли ви робите новий комміт. Це може бути досить небезпечно,
якщо ви не усвідомлюєте, що робите. Якщо ви хочете вилучити файл лише з робочого каталогу,
а не зі змісту репозиторія, скористайтеся звичайною командою rm. Видаляючи файли з репозиторію,
ви не видаляєте їх з історії, оскільки це було б нечесно. Якщо ви хочете видалити файл,
який було стадійовано, але не закоммітено, вам слід додати опцію --cached, як у прикладі:
```
git add myfile
git rm myfile --cached
```

```
git mv
```
Перейменовує файл і вносить нове ім'я файлу до репозиторія.
Це еквівалентно перейменуванню робочого файлу, а потім виконанню
git rm для старого імені файлу і git add для нового,
тобто наступні операції є еквівалентними (будь ласка,
подивіться на команди нижче). Це проста операція в Git'і,
якщо порівнювати зі старими системами керування версіями,
де перейменування файлу означає фактичне видалення старого
і додавання нового файлу. У цьому випадку бінарні блоби,
пов'язані з файлом, залишаються незмінними, оновлюється лише зміст (індекс).

```bash
git mv oldfile newfile
mv oldfile newfile ; git rm oldfile ; git add newfile
```

Нижче наведено таблицю, яка показує, як працюють усі три етапи:

|Команда	|  Вихідний файл	  |   Зміст (Index)	        |   Ланцюжок коммітів |	Посилання|
|:------:|:-----------------|:-------------------------|:-------------------:|:----------:|
|git add |  Без змін	      |   Оновлено новим файлом	 | Без змін	          |   Без змін |
|git rm	|  Файл видалено	  |   Файл видалено	         | Без змін	          |   Без змін |
|git mv	|  Файл переміщено |   Оновлено ім'я 	        | Без змін	           |   Без змін |
|        |  /перейменовано  |  /розташування файлу     |                     |            |


```bash
git ls-files
```
Показує інформацію про файли в змістовому (індексному) та робочому дереві.
За замовчуванням ця команда показує лише файли у репозиторії.
Якщо ви хочете показати невідстежувані файли, скористайтеся наведеною нижче командою,
де параметр --otheres показує невідстежувані файли, а параметр --exclude-standard
вказує ігнорувати стандартні винятки, такі як файли .gitignore.
```bash
git ls-files --others --exclude-standard
```

```bash
git ls-files -t
```
Команда `git ls-files -t` використовується для виведення списку файлів,
що знаходяться в репозиторії Git, разом з їх станом. За допомогою опції
`-t` команда виводить режим стеження за кожним файлом. Відомі режими включають:
`C` - зіткнення (conflict), коли файл має конфлікти при злитті гілок.
`M` - змінений (modified), коли файл був змінений в робочій копії.
`R` - перейменований (renamed), коли файл був перейменований.
`A` - доданий (added), коли файл був доданий до репозиторію.
`D` - видалений (deleted), коли файл був видалений з репозиторію.
`U` - невідомий (untracked), коли файл не є відстежуваним Git.

```bash
git ls-files -o
```
Команда `git ls-files -o` виводить список невідстежуваних файлів в репозиторії Git.
Опція `-o` вказує Git шукати лише невідстежувані файли. Ці файли не включені до
контролю версій Git і не входять до комітів. Вони можуть бути новими файлами,
які ще не були додані до стеження, або файлами, які були виключені зі стеження
за допомогою файлу .gitignore.

Команда `git ls-files` використовується для виведення інформації про файли,
що перебувають під версійним контролем Git. Деякі з опцій, доступних для
команди `git ls-files`, включають:


`-s`, `--stage`: Виводить результати в форматі, який включає статус файлу та його SHA-1 хеш.
`-t`, `--cached`: Виводить лише відстежувані файли (файли, які знаходяться в зоні індекса).
`-o`, `--others`: Виводить лише файли, які не відстежуються або не знаходяться в зоні індекса.
`-i`, `--ignored`: Виводить файли, які знаходяться в стані "ignored" (виключені) відповідно
до файлу .gitignore або інших шаблонів виключення.
`-u`, `--unmerged`: Виводить файли, які мають конфлікти злиття (незлиті файли).
`-r`, `--recurse-submodules`: Рекурсивно виводить файли підмодулів.
`-z`: Виводить результати, розділені нуль-символами, замість пробілів.
`--error-unmatch`: Припиняє виконання команди з помилкою, якщо не знайдено жодного відповідного файлу.
Наприклад, команда `git ls-files -s` виведе список файлів з їхніми статусами, а команда
`git ls-files -t -o` виведе лише файли, які не відстежуються або не знаходяться в зоні індекса.

Більш детальну інформацію про опції команди `git ls-files` ви можете знайти у документації Git,
використовуючи команду `git help ls-files`.

```bash
git commit -a -s -m "третій комміт"
```
де `-a` або `--all`: Ця опція дозволяє автоматично додавати всі змінені файли до коміту
без необхідності використовувати окрему команду `git add`. Зверніть увагу, що це діє тільки
на файли, які вже відстежуються Git. Нові файли, які не додані до відстеження, не будуть включені в коміт.

```bash
git ls-files -t -c -o -s
```
`-t` або `--type`: Ця опція дозволяє вивести тип кожного файла.
Наприклад, типи файлів можуть бути "blob" (для звичайного файлу),
"tree" (для каталогу) або "commit" (для коміту).
`-c` або `--cached`: Ця опція виводить лише відстежувані (cached) файли,
тобто файли, які вже додані до індексу Git і готові для коміту.
`-o` або `--others`: Ця опція виводить лише файли, які не є відстежуваними (untracked),
тобто файли, які не були додані до індексу Git.
`-s` або `--stage`: Ця опція виводить інформацію про файл у форматі "стадії" (stage).
Вона включає режим виводу, де файли позначаються номерами стадій (stage numbers),
що вказують їх статус відносно індексу Git (0 - незмінений, 1 - змінений, 2 - видалений, і т.д.).
Таким чином, команда `git ls-files -t -c -o -s` виводить інформацію про всі файли
в репозиторії, включаючи їх тип, статус відносно індексу Git (cached або untracked)
та номер стадії, якщо вони наявні.
