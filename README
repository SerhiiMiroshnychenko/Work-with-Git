GIT

Ви можете побачити версію Git'а, яку ви встановили: 
$ git --version

Детальну довідкову інформацію у вигляді man-сторінки можна отримати про будь-яку підкоманду, виконавши: 
$ git help [subcommand]

Наприклад: 
$ git help status

Якщо ви не можете втриматися від перегляду повнішого набору команд, це можна зробити ось так: 
$ git help --all

Якщо ви створюєте новий репозиторій, найпростіший спосіб зробити це з самого початку - зробити щось на кшталт:
$ git init
$ git checkout -b main

Для вже наявних репозиторіїв ви можете перейменувати як локальну гілку, так і віддалену гілку на сервері з:

$ git checkout master
# Змінити локальну назву
$ git branch -m master main

# Змінити віддалену назву
$ git push -u origin main
$ git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main

# Підтвердити імена!
$ git branch -a

Залежно від налаштувань віддаленого сервера (наприклад, GitHub) це може спрацювати, а може і не спрацювати. Простіший підхід - не видаляти гілку master, а просто скопіювати її в main і працювати звідти, як і раніше:

$ git checkout master
$ git branch main
$ git checkout main
$ git push -u origin main

а потім просто ігноруйте гілку master надалі. 

Під час ініціалізації проєкту створюється каталог .git, який міститиме всю інформацію про керування версіями. Основні каталоги, що входять до складу проєкту, залишаються недоторканими. 

Початковий вміст цього каталогу має вигляд:

$ ls -l .git

Далі ми створюємо файл і додаємо його до проєкту:

​$ echo some junk > somejunkfile
$ git add somejunkfile

Ми можемо бачити поточний стан нашого проєкту за допомогою:

​$ git status

Тепер давайте змінимо файл, а потім подивимося історію відмінностей:

​$ echo another line >> somejunkfile
$ git diff

Для того, щоб фактично закоммітити зміни в репозиторії, ми це робимо: 

$ git add somejunkfile
$ git commit -m "My initial commit"

Ви можете переглянути свою історію за допомогою:

$ git log

Підпис коммітів
Важливо знати, хто відповідає за всі зміни в репозиторії, щоб відстежувати історію і розуміти,
хто гарантує, що код, який вноситься до репозиторію, робиться з належним ліцензуванням і правом власності.
Найпростіше це зробити, додавши до комміту рядок Signed-off-by з опцією -s. Так ми могли б зробити:

$ git commit -s -m "My initial commit"

Кожен репозииторій також містить набір конфігураційних параметрів, таких як ім'я автора та адреса електронної пошти. Наприклад, якщо ми подивимося на файл .git/config з простого прикладу у попередньому розділі, то побачимо:

​$ cat .git/config

Основні файлові команди

git add
Додає один або кілька файлів у вигляді блобів до сховища об'єктів і додає посилання на нові блоби до змісту за допомогою sha1-хешу. Таким чином, ми індексуємо один або кілька файлів і каталогів. Він може бути використаний як для додавання нових файлів, так і для збереження змінених. Файли не будуть закоммітені, доки не буде зроблено git commit. Існує кілька варіантів (див. довідку git help add). Наприклад, ви можете використовувати -i для інтерактивного вибору файлів для стадії або -u для оновлення лише тих файлів, які вже відомі Git'у. Ви також можете вказати шаблони підстановки або імена каталогів (в яких буде додано все дерево підкаталогів). Варто повторити, що поки ви не зробите git commit, зміни лише стадіюються; репозиторій не оновлюється. 

git rm
Видаляє файл з робочого дерева та змісту (індексу), але не видаляє його з репозиторію; це відбувається лише тоді, коли ви робите новий комміт. Це може бути досить небезпечно, якщо ви не усвідомлюєте, що робите. Якщо ви хочете вилучити файл лише з робочого каталогу, а не зі змісту репозиторія, скористайтеся звичайною командою rm. Видаляючи файли з репозиторію, ви не видаляєте їх з історії, оскільки це було б нечесно. Якщо ви хочете видалити файл, який було стадійовано, але не закоммітено, вам слід додати опцію --cached, як у прикладі:

$ git add myfile

$ git rm myfile --cached

git mv
Перейменовує файл і вносить нове ім'я файлу до репозиторія. Це еквівалентно перейменуванню робочого файлу, а потім виконанню  git rm для старого імені файлу і git add для нового, тобто наступні операції є еквівалентними (будь ласка, подивіться на команди нижче). Це проста операція в Git'і,якщо порівнювати зі старими системами керування версіями, де перейменування файлу означає фактичне видалення старого і додавання нового файлу. У цьому випадку бінарні блоби, пов'язані з файлом, залишаються незмінними, оновлюється лише зміст (індекс).

$ git mv oldfile newfile

$ mv oldfile newfile ; git rm oldfile ; git add newfile

Нижче наведено таблицю, яка показує, як працюють усі три етапи.

Команда	  Вихідний файл	   Зміст (Index)	          Ланцюжок коммітів 	Посилання
git add	  Без змін	         Оновлено новим файлом	Без змін	           Без змін
git rm	  Файл видалено	     Файл видалено	        Без змін	           Без змін
git mv	  Файл переміщено    Оновлено ім'я 	          Без змін	            Без змін
          /перейменовано     /розташування файлу


git ls-files
Показує інформацію про файли в змістовому (індексному) та робочому дереві.
За замовчуванням ця команда показує лише файли у репозиторії.
Якщо ви хочете показати невідстежувані файли, скористайтеся наведеною нижче командою,
де параметр --otheres показує невідстежувані файли, а параметр --exclude-standard
вказує ігнорувати стандартні винятки, такі як файли .gitignore.

$ git ls-files --others --exclude-standard