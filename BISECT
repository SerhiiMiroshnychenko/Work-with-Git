Припустимо, у вас була версія коду, яка працювала, а тепер, через багато версій (і коммітів),
ви виявили, що вона більше не працює.

Git має можливість поділити навпіл (бісектувати), щоб швидко знайти набір змін, який все зіпсував.
Кількість кроків не перевищує логарифм за основою 2 від кількості коммітів, що набагато швидше,
ніж при звичайному переборі. Іншими словами, якщо погана зміна була зроблена десь в останніх
1024 коммітах, ви можете знайти її не більше ніж за 10 кроків поділу навпіл (бісекції).

Спочатку вам потрібно зробити:

$ git bisect start
$ git bisect bad
$ git bisect good V_10

де передбачається, що поточний комміт поганий, а версія V_10 відома як хороша.
Після цього Git залишить вас на комміті на півдорозі між цими двома версіями.
Після цього ви тестуєте код, щоб перевірити, чи помилка все ще там.

Якщо так, ви вводите код:

$ git bisect bad

Якщо в коді ще немає помилки, ви вводите:

$ git bisect good

Ви продовжуєте це ітеративно, поки не знайдете баг.

Потім ви вводите:

$ git bisect reset

щоб повернутися до поточного робочого стану.

Якщо є можливість написати скрипт, який перевіряє поточну версію на наявність помилки,
процес стає ще простішим.

Припустимо, ви написали скрипт my_script.sh, який повертає 0, якщо поточна версія хороша,
і будь-яке значення від 1 до 127, якщо вона погана. Тоді, після ініціалізації поділу
навпіл (бісекції) з хорошою і поганою версією, ви можете просто зробити:

$ git bisect run ./myscript.sh

і процес завершиться, коли буде знайдено баг. 

Ви можете відтворити історію поділу навпіл (бісекції) за допомогою git bisect log
або git bisect visualize.

Якщо ви робите невеликі інкрементні набори змін, баги можна знайти дуже швидко
за допомогою поділу навпіл (бісекції). У коммітах з великою кількістю змін буде
досить багато місць, які, можливо, доведеться перевіряти навіть після того, як
ви визначите останню робочу версію і першу несправну.
